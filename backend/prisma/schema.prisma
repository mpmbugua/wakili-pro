generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String             @id @default(cuid())
  email              String             @unique
  password           String
  role               UserRole
  firstName          String
  lastName           String
  phoneNumber        String?
  verificationStatus VerificationStatus @default(PENDING)
  emailVerified      Boolean            @default(false)
  emailVerificationToken String?
  passwordResetToken String?
  passwordResetExpires DateTime?
  
  profile            UserProfile?
  lawyerProfile      LawyerProfile?
  subscription       Subscription?
  
  // Marketplace relations
  servicesOffered    MarketplaceService[] @relation("ServiceProvider")
  bookingsAsClient   ServiceBooking[]     @relation("ServiceClient")
  bookingsAsProvider ServiceBooking[]     @relation("ServiceProvider")
  reviewsGiven       ServiceReview[]      @relation("ReviewAuthor")
  reviewsReceived    ServiceReview[]      @relation("ReviewTarget")
  
  // Payment relations
  payments           Payment[]
  refundsRequested   Refund[]
  walletTransactions WalletTransaction[]
  
  // Video consultation relations
  lawyerConsultations VideoConsultation[]  @relation("LawyerConsultations")
  clientConsultations VideoConsultation[]  @relation("ClientConsultations")
  videoParticipants   VideoParticipant[]
  
  // Chat relations
  chatRoomsAsClient  ChatRoom[]       @relation("ChatClient")
  chatRoomsAsLawyer  ChatRoom[]       @relation("ChatLawyer")
  messagesSent       ChatMessage[]    @relation("MessageSender")
  notifications      Notification[]
  
  // Mobile relations
  deviceRegistrations DeviceRegistration[]
  
  // Authentication relations
  refreshTokens      RefreshToken[]
  
  // Case management (for lawyers)
  cases              Case[]
  
  // AI query history
  aiQueries          AIQuery[]
  
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

model UserProfile {
  id        String  @id @default(cuid())
  userId    String  @unique
  bio       String?
  avatarUrl String?
  county    String?
  city      String?
  
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("user_profiles")
}

model LawyerProfile {
  id                String               @id @default(cuid())
  userId            String               @unique
  licenseNumber     String               @unique
  yearOfAdmission   Int
  specializations   Json                 // Array of LegalSpecialization
  location          Json                 // LocationData object
  bio               String
  yearsOfExperience Int
  rating            Float                @default(0)
  reviewCount       Int                  @default(0)
  isVerified        Boolean              @default(false)
  profileImageUrl   String?
  availability      Json                 // Array of WorkingHours
  
  user              User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // CLE/CPD tracking
  cleRecords        CLERecord[]
  
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt

  @@map("lawyer_profiles")
}

model Subscription {
  id                   String             @id @default(cuid())
  userId               String             @unique
  tier                 SubscriptionTier
  status               SubscriptionStatus
  priceKES             Int
  billingCycle         BillingCycle
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  trialEnd             DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)
  paymentMethod        String?
  
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  @@map("subscriptions")
}

model MarketplaceService {
  id               String           @id @default(cuid())
  type             ServiceType
  title            String
  description      String
  providerId       String
  priceKES         Int
  duration         Int?             // For consultations (minutes)
  deliveryTimeframe String?         // "2-3 business days"
  rating           Float            @default(0)
  reviewCount      Int              @default(0)
  status           ServiceStatus    @default(ACTIVE)
  tags             String[]
  
  provider         User             @relation("ServiceProvider", fields: [providerId], references: [id])
  bookings         ServiceBooking[]
  reviews          ServiceReview[]
  
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  @@map("marketplace_services")
}

model ServiceBooking {
  id                 String         @id @default(cuid())
  serviceId          String
  clientId           String
  providerId         String
  scheduledAt        DateTime?      // For consultations
  status             BookingStatus  @default(PENDING)
  paymentStatus      PaymentStatus  @default(PENDING)
  totalAmountKES     Int
  clientRequirements String
  providerNotes      String?
  deliverables       Json?          // Array of BookingDeliverable
  
  service            MarketplaceService @relation(fields: [serviceId], references: [id])
  client             User           @relation("ServiceClient", fields: [clientId], references: [id])
  provider           User           @relation("ServiceProvider", fields: [providerId], references: [id])
  payments           Payment[]
  videoConsultation  VideoConsultation?
  chatRoom           ChatRoom?
  
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  @@map("service_bookings")
}

model Payment {
  id                    String         @id @default(cuid())
  bookingId             String
  userId                String
  amount                Float
  method                PaymentMethod
  status                PaymentStatus  @default(PENDING)
  externalTransactionId String?        // M-Pesa/Stripe transaction ID
  metadata              Json?          // Additional payment data
  verifiedAt            DateTime?
  
  booking               ServiceBooking @relation(fields: [bookingId], references: [id])
  user                  User           @relation(fields: [userId], references: [id])
  escrowTransaction     EscrowTransaction?
  refunds               Refund[]
  
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  @@map("payments")
}

model EscrowTransaction {
  id            String           @id @default(cuid())
  paymentId     String           @unique
  amount        Float
  status        EscrowStatus     @default(HELD)
  releaseDate   DateTime?        // Auto-release date
  releasedAt    DateTime?        // Actual release date
  platformFee   Float?
  lawyerPayout  Float?
  
  payment       Payment          @relation(fields: [paymentId], references: [id])
  
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  @@map("escrow_transactions")
}

model Refund {
  id                String        @id @default(cuid())
  paymentId         String
  amount            Float
  reason            String
  status            RefundStatus  @default(PENDING)
  externalRefundId  String?       // Stripe refund ID or M-Pesa reference
  requestedBy       String        // User ID who requested refund
  processedAt       DateTime?
  
  payment           Payment       @relation(fields: [paymentId], references: [id])
  requester         User          @relation(fields: [requestedBy], references: [id])
  
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  @@map("refunds")
}

model WalletTransaction {
  id            String              @id @default(cuid())
  userId        String
  type          WalletTransactionType
  amount        Float
  balance       Float?              // Wallet balance after transaction
  description   String
  referenceId   String?             // Booking ID, Payment ID, etc.
  status        TransactionStatus   @default(COMPLETED)
  
  user          User                @relation(fields: [userId], references: [id])
  
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@map("wallet_transactions")
}

model VideoConsultation {
  id                String                    @id @default(cuid())
  bookingId         String                    @unique
  lawyerId          String
  clientId          String
  status            VideoConsultationStatus   @default(SCHEDULED)
  roomId            String                    @unique
  scheduledAt       DateTime
  startedAt         DateTime?
  endedAt           DateTime?
  duration          Int?                      // Duration in minutes
  recordingUrl      String?                   // Recording if enabled
  meetingNotes      String?
  participantCount  Int                       @default(0)
  maxParticipants   Int                       @default(2)
  isRecorded        Boolean                   @default(false)
  recordingStartedAt DateTime?
  recordingEndedAt   DateTime?
  
  booking           ServiceBooking            @relation(fields: [bookingId], references: [id])
  lawyer            User                      @relation("LawyerConsultations", fields: [lawyerId], references: [id])
  client            User                      @relation("ClientConsultations", fields: [clientId], references: [id])
  participants      VideoParticipant[]
  recordings        ConsultationRecording[]
  
  createdAt         DateTime                  @default(now())
  updatedAt         DateTime                  @updatedAt

  @@map("video_consultations")
}

model VideoParticipant {
  id                  String               @id @default(cuid())
  consultationId      String
  userId              String
  participantType     ParticipantType
  joinedAt            DateTime?
  leftAt              DateTime?
  connectionStatus    ConnectionStatus     @default(DISCONNECTED)
  hasVideo            Boolean              @default(true)
  hasAudio            Boolean              @default(true)
  isScreenSharing     Boolean              @default(false)
  peerId              String?              // WebRTC peer ID
  
  consultation        VideoConsultation    @relation(fields: [consultationId], references: [id])
  user                User                 @relation(fields: [userId], references: [id])
  
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt

  @@unique([consultationId, userId])
  @@map("video_participants")
}

model ConsultationRecording {
  id                String               @id @default(cuid())
  consultationId    String
  fileName          String
  storageKey        String               // Key for storage provider (S3/R2/local)
  fileSize          BigInt               // File size in bytes
  duration          Int                  // Duration in seconds
  format            String               // webm, mp4, etc.
  codec             String               // VP9, H264, etc.
  resolution        String               // 1920x1080, 1280x720, etc.
  uploadedAt        DateTime             @default(now())
  isProcessed       Boolean              @default(false)
  processingStatus  String?              // PENDING, PROCESSING, COMPLETED, FAILED
  thumbnailKey      String?              // Thumbnail image key
  
  consultation      VideoConsultation    @relation(fields: [consultationId], references: [id], onDelete: Cascade)
  
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt

  @@map("consultation_recordings")
}

model DeviceRegistration {
  id            String               @id @default(cuid())
  userId        String
  deviceToken   String               @unique
  platform      String               // ios, android, web
  appVersion    String               @default("1.0.0")
  isActive      Boolean              @default(true)
  lastSeen      DateTime             @default(now())
  
  user          User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  @@map("device_registrations")
}

model ChatRoom {
  id            String       @id @default(cuid())
  bookingId     String       @unique
  clientId      String
  lawyerId      String
  status        ChatStatus   @default(ACTIVE)
  lastActivity  DateTime     @default(now())
  
  booking       ServiceBooking @relation(fields: [bookingId], references: [id])
  client        User         @relation("ChatClient", fields: [clientId], references: [id])
  lawyer        User         @relation("ChatLawyer", fields: [lawyerId], references: [id])
  messages      ChatMessage[]
  
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@map("chat_rooms")
}

model ChatMessage {
  id            String       @id @default(cuid())
  roomId        String
  senderId      String
  content       String
  messageType   MessageType  @default(TEXT)
  fileUrl       String?      // For file attachments
  fileName      String?      // Original file name
  fileSize      Int?         // File size in bytes
  isRead        Boolean      @default(false)
  editedAt      DateTime?    // If message was edited
  
  room          ChatRoom     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  sender        User         @relation("MessageSender", fields: [senderId], references: [id])
  
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@map("chat_messages")
}

model Notification {
  id            String           @id @default(cuid())
  userId        String
  type          NotificationType
  title         String
  message       String
  data          Json?            // Additional notification data
  isRead        Boolean          @default(false)
  readAt        DateTime?
  
  user          User             @relation(fields: [userId], references: [id])
  
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  @@map("notifications")
}

model ServiceReview {
  id         String   @id @default(cuid())
  serviceId  String
  authorId   String   // Client who wrote the review
  targetId   String   // Lawyer being reviewed
  rating     Int      // 1-5 stars
  comment    String
  
  service    MarketplaceService @relation(fields: [serviceId], references: [id])
  author     User     @relation("ReviewAuthor", fields: [authorId], references: [id])
  target     User     @relation("ReviewTarget", fields: [targetId], references: [id])
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  @@unique([serviceId, authorId]) // One review per client per service
  @@map("service_reviews")
}

model Case {
  id            String        @id @default(cuid())
  lawyerId      String
  clientId      String?
  title         String
  caseNumber    String?
  court         String?
  caseType      CaseType
  status        CaseStatus    @default(ACTIVE)
  dateOpened    DateTime      @default(now())
  dateClosed    DateTime?
  description   String
  
  lawyer        User          @relation(fields: [lawyerId], references: [id])
  documents     CaseDocument[]
  events        CaseEvent[]
  billingEntries BillingEntry[]
  
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@map("cases")
}

model CaseDocument {
  id          String    @id @default(cuid())
  caseId      String
  name        String
  fileUrl     String
  fileType    String
  fileSize    Int
  uploadedBy  String
  
  case        Case      @relation(fields: [caseId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("case_documents")
}

model CaseEvent {
  id          String    @id @default(cuid())
  caseId      String
  title       String
  description String?
  eventDate   DateTime
  eventType   String    // "HEARING", "FILING", "MEETING", etc.
  location    String?
  
  case        Case      @relation(fields: [caseId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("case_events")
}

model BillingEntry {
  id          String    @id @default(cuid())
  caseId      String
  description String
  timeSpent   Int       // minutes
  hourlyRate  Float
  totalAmount Float
  date        DateTime
  isBillable  Boolean   @default(true)
  
  case        Case      @relation(fields: [caseId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("billing_entries")
}

model CLERecord {
  id             String           @id @default(cuid())
  lawyerId       String
  activityType   CLEActivityType
  title          String
  provider       String
  hoursEarned    Float
  dateCompleted  DateTime
  certificateUrl String?
  status         CLEStatus        @default(PENDING)
  
  lawyer         LawyerProfile    @relation(fields: [lawyerId], references: [id], onDelete: Cascade)
  
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  @@map("cle_records")
}

model AIQuery {
  id          String    @id @default(cuid())
  userId      String
  query       String
  type        AIQueryType
  context     AIContext
  response    String
  confidence  Float
  tokensUsed  Int
  
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime  @default(now())

  @@map("ai_queries")
}

model LegalNewsItem {
  id          String       @id @default(cuid())
  title       String
  content     String
  summary     String
  source      String
  category    NewsCategory
  tags        String[]
  publishedAt DateTime
  imageUrl    String?
  externalUrl String?
  isBreaking  Boolean      @default(false)
  viewCount   Int          @default(0)
  
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@map("legal_news")
}

enum UserRole {
  PUBLIC
  LAWYER
  ADMIN
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum SubscriptionTier {
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
  TRIALING
}

enum BillingCycle {
  MONTHLY
  ANNUAL
}

enum ServiceType {
  CONSULTATION
  DOCUMENT_DRAFTING
  LEGAL_REVIEW
  IP_FILING
  DISPUTE_MEDIATION
  CONTRACT_NEGOTIATION
}

enum ServiceStatus {
  ACTIVE
  PAUSED
  INACTIVE
}

enum BookingStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  REFUNDED
  FAILED
}

enum CaseType {
  CIVIL
  CRIMINAL
  FAMILY
  CORPORATE
  PROPERTY
  EMPLOYMENT
  CONSTITUTIONAL
}

enum CaseStatus {
  ACTIVE
  PENDING
  CLOSED
  ARCHIVED
}

enum CLEActivityType {
  SEMINAR
  CONFERENCE
  ONLINE_COURSE
  WRITING
  TEACHING
  PRO_BONO
}

enum CLEStatus {
  PENDING
  APPROVED
  REJECTED
}

enum AIQueryType {
  VOICE
  TEXT
}

enum AIContext {
  LEGAL_ADVICE
  DOCUMENT_GENERATION
  LEGAL_RESEARCH
  CASE_ANALYSIS
}

enum NewsCategory {
  LEGISLATION
  COURT_DECISIONS
  LEGAL_PRACTICE
  REGULATORY_UPDATES
  INDUSTRY_NEWS
  INTERNATIONAL_LAW
}

enum PaymentMethod {
  MPESA
  STRIPE_CARD
  BANK_TRANSFER
  WALLET
}

enum EscrowStatus {
  HELD
  RELEASED
  CANCELLED
}

enum RefundStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REJECTED
}

enum WalletTransactionType {
  DEPOSIT
  WITHDRAWAL
  PAYMENT
  REFUND
  PAYOUT
  FEE
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum VideoConsultationStatus {
  SCHEDULED
  WAITING_FOR_PARTICIPANTS
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum ParticipantType {
  LAWYER
  CLIENT
  OBSERVER
}

enum ConnectionStatus {
  DISCONNECTED
  CONNECTING
  CONNECTED
  RECONNECTING
  FAILED
}

enum ChatStatus {
  ACTIVE
  CLOSED
  ARCHIVED
}

enum MessageType {
  TEXT
  FILE
  IMAGE
  DOCUMENT
  SYSTEM
}

enum NotificationType {
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  MESSAGE_RECEIVED
  SERVICE_REVIEW
  SYSTEM_ANNOUNCEMENT
}