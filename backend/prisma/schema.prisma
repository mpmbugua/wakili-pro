// --- Added missing models for backend compatibility ---
model AppSetting {
  key   String @id
  value String
}

model DocumentTemplate {
    purchases DocumentPurchase[] @relation("TemplatePurchases")
  id          String   @id @default(cuid())
  name        String
  description String?
  content     String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model DocumentPurchase {
  id            String   @id @default(cuid())
  userId        String
  templateId    String
  purchasedAt   DateTime @default(now())
  user          User     @relation("UserDocumentPurchases", fields: [userId], references: [id])
  template      DocumentTemplate @relation("TemplatePurchases", fields: [templateId], references: [id])
}

model ConsultationRecording {
  id                String   @id @default(cuid())
  consultationId    String
  url               String
  startedAt         DateTime
  endedAt           DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model DeviceRegistration {
  id        String   @id @default(cuid())
  userId    String
  deviceId  String
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}
model LawyerProfile {
  id             String   @id @default(cuid())
  userId         String   @unique
  licenseNumber  String?
  tier           LawyerTier @default(LITE)
  specializations String[]
  phoneNumber    String?
  yearOfAdmission Int?
  location       String?
  isVerified     Boolean @default(false)
  rating         Float? @default(0)
  reviewCount    Int? @default(0)
  isFeatured     Boolean @default(false)
  featuredUntil  DateTime?
  status         String? @default("ACTIVE")
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- User and Profile Models ---
model User {
  id                 String   @id @default(cuid())
  email              String   @unique
  password           String
  role               UserRole
  firstName          String
  lastName           String
  phoneNumber        String?
  verificationStatus VerificationStatus @default(PENDING)
  emailVerified      Boolean  @default(false)
  emailVerificationToken String?
  passwordResetToken String?
  passwordResetExpires DateTime?
  profile            UserProfile?
  lawyerProfile      LawyerProfile?
  // Relations
  servicesOffered    MarketplaceService[] @relation("ServiceProvider")
  bookingsAsClient   ServiceBooking[]     @relation("ServiceClient")
  bookingsAsProvider ServiceBooking[]     @relation("ServiceProvider")
  reviewsGiven       ServiceReview[]      @relation("ReviewAuthor")
  reviewsReceived    ServiceReview[]      @relation("ReviewTarget")
  payments           Payment[]
  refundsRequested   Refund[]
  walletTransactions WalletTransaction[]
  notifications      Notification[]
  // Opposite relations for ChatRoom and ChatMessage
  chatRoomsAsClient  ChatRoom[] @relation("ChatClient")
  chatRoomsAsLawyer  ChatRoom[] @relation("ChatLawyer")
  messagesSent       ChatMessage[] @relation("MessageSender")
  lawyerConsultations VideoConsultation[] @relation("LawyerConsultations")
  clientConsultations VideoConsultation[] @relation("ClientConsultations")
  videoParticipants VideoParticipant[]
  documentPurchases DocumentPurchase[] @relation("UserDocumentPurchases")
  deviceRegistrations DeviceRegistration[]
  refreshTokens RefreshToken[]
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model UserProfile {
  id           String   @id @default(cuid())
  userId       String   @unique
  bio          String?
  avatarUrl    String?
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}
model VideoParticipant {
  id                String   @id @default(uuid())
  userId            String
  consultationId    String
  joinedAt          DateTime @default(now())
  leftAt            DateTime?
  videoConsultation VideoConsultation @relation(fields: [consultationId], references: [id])
  user              User @relation(fields: [userId], references: [id])
}

model LegalEvent {
  id                String   @id @default(uuid())
  title             String
  description       String?
  eventType         String
  eventDate         DateTime
  sourceUrl         String?
  notifiedImmediate Boolean @default(false)
  notified24h       Boolean @default(false)
  notified30min     Boolean @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

// --- Marketplace Models ---
model MarketplaceService {
  id          String   @id @default(cuid())
  title       String
  type        ServiceType
  providerId  String
  description String?
  price       Float
  priceKES    Int?
  tags        String[]
  status      ServiceStatus @default(ACTIVE)
  rating      Float? @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  provider    User     @relation("ServiceProvider", fields: [providerId], references: [id], onDelete: Cascade)
  bookings    ServiceBooking[]
  reviews     ServiceReview[]
}

model ServiceBooking {
  id             String   @id @default(cuid())
  clientId       String
  providerId     String
  serviceId      String
  status         BookingStatus
  scheduledAt    DateTime
  completedAt    DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  client         User     @relation("ServiceClient", fields: [clientId], references: [id])
  provider       User     @relation("ServiceProvider", fields: [providerId], references: [id])
  service        MarketplaceService @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  payments       Payment[]
  chatRooms      ChatRoom[]
  videoConsultation VideoConsultation?
}

model ServiceReview {
  id         String   @id @default(cuid())
  serviceId  String
  authorId   String
  targetId   String
  rating     Int
  comment    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  service    MarketplaceService @relation(fields: [serviceId], references: [id])
  author     User     @relation("ReviewAuthor", fields: [authorId], references: [id])
  target     User     @relation("ReviewTarget", fields: [targetId], references: [id])
}

// --- Payment and Wallet Models ---
model Payment {
  id          String   @id @default(cuid())
  userId      String
  bookingId   String?
  amount      Float
  status      PaymentStatus
  method      PaymentMethod
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id])
  booking     ServiceBooking? @relation(fields: [bookingId], references: [id])
  refunds     Refund[]
}

model Refund {
  id          String   @id @default(cuid())
  paymentId   String
  userId      String
  amount      Float
  reason      String
  status      RefundStatus
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  payment     Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model WalletTransaction {
  id          String   @id @default(cuid())
  userId      String
  amount      Float
  type        WalletTransactionType
  status      TransactionStatus
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id])
}

// --- Notification and Chat Models ---
model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  isRead    Boolean  @default(false)
  readAt    DateTime?
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])
}

model ChatRoom {
  id            String   @id @default(cuid())
  bookingId     String
  clientId      String
  lawyerId      String
  status        ChatStatus   @default(ACTIVE)
  lastActivity  DateTime     @default(now())
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  messages      ChatMessage[]
  booking       ServiceBooking @relation(fields: [bookingId], references: [id])
  client        User         @relation("ChatClient", fields: [clientId], references: [id])
  lawyer        User         @relation("ChatLawyer", fields: [lawyerId], references: [id])
}

model ChatMessage {
  id            String   @id @default(cuid())
  roomId        String
  senderId      String
  content       String
  messageType   MessageType  @default(TEXT)
  fileUrl       String?
  fileName      String?
  fileSize      Int?
  isRead        Boolean  @default(false)
  editedAt      DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  room          ChatRoom     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  sender        User         @relation("MessageSender", fields: [senderId], references: [id])
}

// --- Enums ---
enum UserRole {
  PUBLIC
  LAWYER
  ADMIN
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum LawyerTier {
  LITE
  PRO
}

enum ServiceType {
  CONSULTATION
  DOCUMENT_DRAFTING
  LEGAL_REVIEW
  IP_FILING
  DISPUTE_MEDIATION
  CONTRACT_NEGOTIATION
}

enum ServiceStatus {
  ACTIVE
  PAUSED
  INACTIVE
}

enum BookingStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  REFUNDED
  FAILED
}

enum PaymentMethod {
  MPESA
  STRIPE_CARD
  BANK_TRANSFER
  WALLET
}

enum RefundStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REJECTED
}

model VideoConsultation {
  id           String   @id @default(uuid())
  bookingId    String   @unique
  lawyerId     String
  clientId     String
  roomId       String   @unique
  scheduledAt  DateTime
  isRecorded   Boolean  @default(false)
  status       VideoConsultationStatus @default(SCHEDULED)
  participantCount Int      @default(0)
  endedAt      DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  booking      ServiceBooking @relation(fields: [bookingId], references: [id])
  lawyer       User           @relation("LawyerConsultations", fields: [lawyerId], references: [id])
  client       User           @relation("ClientConsultations", fields: [clientId], references: [id])
  participants VideoParticipant[]
}

enum VideoConsultationStatus {
  SCHEDULED
  ONGOING
  COMPLETED
  CANCELLED
}

enum WalletTransactionType {
  DEPOSIT
  WITHDRAWAL
  PAYMENT
  REFUND
  PAYOUT
  FEE
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum NotificationType {
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  MESSAGE_RECEIVED
  SERVICE_REVIEW
  SYSTEM_ANNOUNCEMENT
}

enum ChatStatus {
  ACTIVE
  CLOSED
  ARCHIVED
}

enum MessageType {
  TEXT
  FILE
  IMAGE
  DOCUMENT
  SYSTEM
}

